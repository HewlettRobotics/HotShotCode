
#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S3, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S4, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     ,               sensorI2CMuxController)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     Flicker,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     Shooter,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     RightDrive,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C1_2,     LeftDrive,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S3_C1_1,     Sweeper,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S3_C1_2,     Lift,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S4_C1_1,    RightServo,           tServoStandard)
#pragma config(Servo,  srvo_S4_C1_2,    LeftServo,            tServoStandard)
#pragma config(Servo,  srvo_S4_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S4_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S4_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S4_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*--------------------------------------------------------------------------------------------------------*\
|*                                                                                                        *|
|*                                    - Tetrix Quiet  Tank Drive -                                        *|
|*                                          ROBOTC on Tetrix                                              *|
|*                                                                                                        *|
|*  This program allows you to drive a robot via remote control using the ROBOTC Debugger.                *|
|*  This particular method uses "Tank Drive" where each side is controlled individually like a tank.      *|
|*  This program also ignores low values that would cause your robot to move when the joysticks fail to   *|
|*  return back to exact center.  You may need to play with the 'threshold' value to get it just right.   *|
|*                                                                                                        *|
|*                                        ROBOT CONFIGURATION                                             *|
|*    NOTES:                                                                                              *|
|*                                                                                                        *|
|*    MOTORS & SENSORS:                                                                                   *|
|*    [I/O Port]              [Name]              [Type]              [Description]                       *|
|*    Port D                  motorD              12V                 Right motor                         *|
|*    Port E                  motorE              12V                 Left motor                          *|
\*---------------------------------------------------------------------------------------------------4246-*/

#include "JoystickDriver.c"

task main()
{
  int threshold = 10;             /* Int 'threshold' will allow us to ignore low       */
                                  /* readings that keep our robot in perpetual motion. */

  while(true)                            // Infinite loop:
  {
    getJoystickSettings(joystick);
    if(abs(joystick.joy1_y2) > threshold)   // If the right analog stick's Y-axis readings are either above or below the threshold:
    {
      motor[RightDrive] = joystick.joy1_y2;         // Motor D is assigned a power level equal to the right analog stick's Y-axis reading.
    }
    else                                    // Else if the readings are within the threshold:
    {
      motor[RightDrive] = 0;                        // Motor D is stopped with a power level of 0.
    }


    if(abs(joystick.joy1_y1) > threshold)   // If the left analog stick's Y-axis readings are either above or below the threshold:
    {
      motor[LeftDrive] = joystick.joy1_y1;         // Motor E is assigned a power level equal to the left analog stick's Y-axis reading.
    }
    else                                    // Else if the readings are within the threshold:
    {
      motor[LeftDrive] = 0;                        // Motor E is stopped with a power level of 0.
    }

    //BUTTON TO CONTROL SWEEPER AND LIFT

    if (joy1Btn(7))
    {
      motor[Sweeper] = 100;
      motor[Lift] = -100;
    }
 		else
 		{
      motor[Sweeper] = 0;
      motor[Lift] = 0;
    }

    //BUTTON TO CONTROL SHOOTER AND FLICKER

    if (joy1Btn(8))
    {
      motor[Shooter] = -100;
      wait1Msec(3000);
      motor[Flicker] = -25;
    }
		else
 		{
      motor[Shooter] = 0;
      motor[Flicker] = 0;

    }

    // BUTTONS TO CONTOL SERVO ARM
    // Control arm via shoulder buttons, 6 & 5

    if(joy1Btn(6))          // If Button 6 is pressed:
    {
      servo[RightServo] = 100;      // Raise RightServo 1 to position 200.
    }
		else
 		{
      servo[RightServo] = 190;
    }
    if(joy1Btn(5))          // If Button 5 is pressed:
    {
      servo[LeftServo] = 150;       // Lower LeftServo 1 to position 200.
    }
    else
 		{
      servo[LeftServo] = 45;
    }
  }
}
